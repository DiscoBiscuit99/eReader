use neon::prelude::*;
use std::fs;

fn print_test(mut cx: FunctionContext) -> JsResult<JsUndefined> {
    println!("Printer testing 1, 2, 3...");
    Ok(cx.undefined())
}

fn get_filenames(mut cx: FunctionContext) -> JsResult<JsArray> {
    let paths = fs::read_dir("./texts").unwrap();

    let mut filenames: Vec<String> = vec![];

    for path in paths {
        filenames.push(path.unwrap().path().display().to_string());
    }

    filenames.sort();

    let js_textnames = JsArray::new(&mut cx, filenames.len() as u32);

    for (i, filename) in filenames.iter().enumerate() {
        let filename_substrings = filename.split("/").collect::<Vec<&str>>();
        let filename_substr = filename_substrings[filename_substrings.len()-1];

        let corrected_filename_vec = filename_substr.split("_").collect::<Vec<&str>>();

        let mut filename_words: Vec<String> = vec![];

        for word in corrected_filename_vec {
            let mut v_char: Vec<char> = word.chars().collect();

            v_char[0] = v_char[0].to_uppercase().nth(0).unwrap();

            let corrected_word: String = v_char.into_iter().collect();

            filename_words.push(corrected_word);
        }

        let corrected_filename = filename_words.join(" ");

        let text_name = corrected_filename.split(".").collect::<Vec<&str>>()[0];
        let js_textname = cx.string(text_name);

        js_textnames.set(&mut cx, i as u32, js_textname).unwrap();
    } 

    Ok(js_textnames)
}

fn get_text_content(mut cx: FunctionContext) -> JsResult<JsArray> {
    let title = cx.argument::<JsString>(0)?.value();

    println!("Converting title {}...", &title);

    let title_chars_temp: Vec<char> = title.chars().collect();
    let mut title_chars: Vec<char> = vec![];
    for c in title_chars_temp {
        &title_chars.push(c.to_lowercase().nth(0).unwrap());
    }

    let mut title_path: String = title_chars.into_iter().collect();

    title_path = title_path.replace(" ", "_");

    let full_path = format!("./texts/{}.txt", title_path);

    let content = fs::read_to_string(full_path).unwrap();

    let paragraphs = content.split("\n").collect::<Vec<&str>>();

    let js_paragraphs = JsArray::new(&mut cx, paragraphs.len() as u32);

    for (i, paragraph) in paragraphs.iter().enumerate() {
        let js_paragraph = cx.string(paragraph);

        js_paragraphs.set(&mut cx, i as u32, js_paragraph).unwrap();
    }

    Ok(js_paragraphs)
}

register_module!(mut m, {
    m.export_function("printTest", print_test)?;
    m.export_function("getFilenames", get_filenames)?;
    m.export_function("getTextContent", get_text_content)?;
    Ok(())
});

